<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulated Large Point Cloud Viewer</title>
    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info-box {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 350px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            z-index: 10;
            line-height: 1.5;
        }
        #info-box h3 {
            margin-top: 0;
            color: #87CEEB; /* Sky blue for headings */
        }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 100;
            flex-direction: column;
            border-radius: 10px;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p>Generating points... This might take a moment.</p>
    </div>

    <div id="info-box">
        <h3>Simulated 3D Point Cloud Viewer</h3>
        <p>This demonstration shows real-time rendering of a large *simulated* point cloud using Three.js.</p>
        <p><strong>Important:</strong> Directly processing 40GB of raw data in a browser is not feasible. Real-world solutions require extensive offline pre-processing (downsampling, LOD, or Gaussian Splatting training) on powerful machines.</p>
        <p>You can drag to rotate and scroll to zoom the point cloud.</p>
        <p>Number of points: <span id="point-count"></span></p>
    </div>

    <script>
        let scene, camera, renderer, controls, points;
        const NUM_POINTS = 1000000; // Simulating 1 million points for demonstration
        const MAX_COORD = 50; // Max coordinate value for generated points

        // Function to initialize the 3D scene
        function init() {
            // Hide loading overlay
            document.getElementById('loading-overlay').style.display = 'none';
            document.getElementById('point-count').innerText = NUM_POINTS.toLocaleString();

            // 1. Create the scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222); // Dark background for better point visibility

            // 2. Create the camera
            camera = new THREE.PerspectiveCamera(
                75, // Field of view
                window.innerWidth / window.innerHeight, // Aspect ratio
                0.1, // Near clipping plane
                1000 // Far clipping plane
            );
            camera.position.z = MAX_COORD * 1.5; // Position camera relative to max coordinate
            camera.position.y = MAX_COORD / 4;

            // 3. Create the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio); // Use device pixel ratio for sharper rendering
            renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to full window
            document.body.appendChild(renderer.domElement); // Add renderer's canvas to the DOM

            // 4. Generate and add a large number of points
            const positions = new Float32Array(NUM_POINTS * 3); // 3 components (x, y, z) per point
            const colors = new Float32Array(NUM_POINTS * 3); // 3 components (r, g, b) per point

            // Simulate a sphere of points for better visual structure
            const sphereRadius = MAX_COORD;
            for (let i = 0; i < NUM_POINTS; i++) {
                // Generate random points within a sphere
                const theta = Math.random() * Math.PI * 2; // Azimuthal angle
                const phi = Math.acos(Math.random() * 2 - 1); // Polar angle (distributes points evenly on sphere)
                const r = sphereRadius * Math.random(); // Random radius within sphere

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // Assign random colors
                colors[i * 3] = Math.random();     // R
                colors[i * 3 + 1] = Math.random(); // G
                colors[i * 3 + 2] = Math.random(); // B
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Create a material for the points
            const material = new THREE.PointsMaterial({
                size: 0.1, // Size of each point
                vertexColors: true, // Use colors from the geometry
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true // Points get smaller when further away
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            // 5. Add OrbitControls for interactive camera movement
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Enable smooth camera movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = MAX_COORD * 3; // Allow zooming out
            controls.maxPolarAngle = Math.PI; // Allow full vertical rotation

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        // Function to handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate); // Request the next frame

            // Update controls
            controls.update();

            // Render the scene
            renderer.render(scene, camera);
        }

        // Start the animation on window load.
        window.onload = function () {
            // Give a brief moment for the loading overlay to show before generating points
            setTimeout(() => {
                init();
                animate();
            }, 100); // Small delay
        };
    </script>
</body>
</html>
