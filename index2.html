<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3d Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info-box {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 350px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            z-index: 10;
            line-height: 1.5;
        }
        #info-box h3 {
            margin-top: 0;
            color: #87CEEB; /* Sky blue for headings */
        }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 100;
            flex-direction: column;
            border-radius: 10px;
            text-align: center;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #error-message {
            color: #ff4d4d;
            font-weight: bold;
            margin-top: 10px;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <p id="loading-text">Loading point data...</p>
    </div>

    <div id="info-box">
        <h3>H-alpha galaxies in a Lightcone Viewer</h3>
        <p>You can drag to rotate and scroll to zoom into the galaxies.</p>
        <p>Number of galaxies: <span id="point-count">0</span></p>
        <p>Ctnl+drag to translate or change the pivot point.</p>
    </div>

    <script>
        let scene, camera, renderer, controls, points; 
        let currentNumPoints = 0;
        let maxCoord = 1; // Will be updated based on loaded data
        const DATA_FILE_PATH = 'points.xyz'; // The name of your data file in the same repository

        // Base64 encoded 32x32 white circle PNG
        // Generated from a small GIMP image (white circle on transparent background)
        const CIRCLE_TEXTURE_DATA = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABz5/reaaAAACyklEQVR4AWJgYGB4w/z//z8zQ0ZGBo8AysQoQeB/sP////9XJBIgRj4gqE8vFvj9//9B6g8gxsX9Byn+w/b+//9w/QcQZ+L6D1L8/v//Y/0HEGbi/g+c+A8YQ4jOgw3d/2P0LxiDCEoRk8f//xi+fwLqD2iC8w+DkGz+f8L5BxrHkCggQJg9f/4C+P//M30HkGbi/g+c+A+MwcQyvH82BvP7z//wHQeL0g/G+P0H//+T/g+MQYQ7y/v/sP7//1T/gcD5BgGDbv4f7d//i/4jGIMITwEwYv/XN2G+f/9Hpv8/GBh+n6D/p2r/gGIMIjA+APUHTD8YfRkGhv+LgYGB4Q+HkO7/wzZ+32D9+/f+/wMY/gfD/gfGICfAfAPp/wef/g9m/g+MwcQyvAAT/4d2b9h/v//x+g9n+Q8MPj8YQxj8D4xBhCcAkDABK/2f2D8z/n37D9B/MfwLqD2jC8w+GkCz+f8L5BwYGIQYRhLcPjAH1BwzD8L8B/S/m/59q+4+x/QeGkCz+f8L5BwMDEMP/Bxm8f2b+B4zBhCeA8Q/kMP7//1T/hxS/2/e2/w8YgwhPAQTwHzb/D9L8/v//w/R/QPwHDCPAfAPo/wef/g9m/g+MwcQyvAAT/4f2b9h/v//x+g9n+Q8MPj8YQxj8D4xBhCcAkDABK/2f2D8z/n37D9B/MfwLqD2jC8w+GkCz+f8L5BwYGIQYRhLcPjAH1BwzD8L8B/S/m/59q+4+x/QeGkCz+f8L5BwMDEMP/Bxm8f2b+B4zBhCeA8Q/kMP7//1T/hxS/2/e2/wQYYABaQ8Yk+sR6iAAAAABJRU5ErkJggg==';

        // ... (rest of your code remains unchanged above this point) ...

        // Function to load and parse XYZ data from a file via fetch
        async function loadPointsFromURL(url) {
            setLoading(true, `Fetching ${url}...`);
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                const lines = text.split('\n');
                const positions = [];
                const colors = [];
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.length === 0 || line.startsWith('#')) continue; // Skip empty lines or comments

                    // Split by space or comma
                    const parts = line.split(/[\s,]+/).map(Number);

                    if (parts.length >= 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                        const x = parts[0];
                        const y = parts[1];
                        const z = parts[2];

                        positions.push(x, y, z);

                        // Update min/max for bounding box calculation
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        minZ = Math.min(minZ, z);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                        maxZ = Math.max(maxZ, z);

                        // Assign random colors for now, can be extended to read RGB if available
                        colors.push(1.0, 1.0, 1.0); // R, G, B values for white (0 to 1)
                    }
                }

                if (positions.length === 0) {
                    showErrorMessage('No valid XYZ data found in the file.');
                    setLoading(false);
                    return;
                }

                currentNumPoints = positions.length / 3;
                document.getElementById('point-count').innerText = currentNumPoints.toLocaleString();

                // Calculate max coordinate extent for camera positioning
                const extentX = maxX - minX;
                const extentY = maxY - minY;
                const extentZ = maxZ - minZ;
                maxCoord = Math.max(extentX, extentY, extentZ) / 2; // Half of max dimension

                // Clear previous points if any
                if (points) {
                    scene.remove(points);
                    points.geometry.dispose();
                    points.material.dispose();
                }

                // Create new geometry and material
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));

                // --- NEW CODE FOR CIRCULAR POINTS ---
                const textureLoader = new THREE.TextureLoader();
                const circleTexture = textureLoader.load(CIRCLE_TEXTURE_DATA);

                const material = new THREE.PointsMaterial({
                    size: 0.1, // Size of each point
                    vertexColors: true, // Use colors from the geometry
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true, // Points get smaller when further away
                    alphaMap: circleTexture, // Apply the circular texture
                    alphaTest: 0.01 // Important for discarding fully transparent pixels
                });
                // --- END NEW CODE ---

                points = new THREE.Points(geometry, material);
                scene.add(points);

                // Reposition camera and controls based on loaded data
                const center = new THREE.Vector3(
                    (minX + maxX) / 2,
                    (minY + maxY) / 2,
                    (minZ + maxZ) / 2
                );
                camera.position.set(center.x + maxCoord * 0.5, center.y + maxCoord * 0.2, center.z + maxCoord * 0.5); 
                camera.lookAt(center);
                controls.target.copy(center);
                controls.maxDistance = maxCoord * 5;
                controls.update();


                setLoading(false);

            } catch (error) {
                console.error("Error loading or processing file:", error);
                showErrorMessage(`Failed to load or process data: ${error.message}. Ensure '${DATA_FILE_PATH}' exists and is correctly formatted.`);
                setLoading(false);
            }
        }

        // Event listeners for file input
        window.onload = function () {
            init(); // Initialize scene first
            loadPointsFromURL(DATA_FILE_PATH); // Automatically load data from the specified file
        };
    </script>
</body>
</html>
